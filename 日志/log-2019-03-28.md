# 前端面试题整理

[toc]

[一年前端面试打怪升级之路（一）](https://www.jianshu.com/p/61aefada8cac)  
[一年前端面试打怪升级之路（二）](https://www.jianshu.com/p/7024a48c65d9)  
[一年前端面试打怪升级之路（三）](https://www.jianshu.com/p/2831cb94fda6)  
[一年前端面试打怪升级之路（四）](https://www.jianshu.com/p/fbd24713ba4a)

## HTML

## CSS
### 选择器和优先级

- 内联样式 
- ID 选择器
- 类选择器 = 属性选择器 = 伪类选择器
- 标签选择器 = 伪元素选择器

伪类：标签状态或逻辑  
伪元素：段落(标签)内的操作,5个，使用::

[选择器-w3c](http://www.w3school.com.cn/cssref/css_selectors.asp)

| -id选择器-            |   ---- 优先级 2 ----            |
| :-------------------  |  :----------------------------  |
| #id                   |   id选择器                      |
| -类选择器-            |                                 |
| .class                |   类选择器                      |
| -属性选择器-          |   ---- 优先级 3 ----            |
| \[attribute]           |   属性选择器                    |
| \[attribute=value]     |   属性-值选择器                 |
| \[attribute~=value]    |   部分属性值选择器 单词匹配     |
| \[attribute|=value]    |   特定属性选择器 单词开头匹配   |
| \[attribute^=value]    |   匹配属性值开头                |
| \[attribute$=value]    |   匹配属性值结尾                |
| \[attribute*=value]    |   匹配子串                      |
| -伪类选择器-          |                                 |
| :link                 |   未访问链接                    |
| :visited              |   已访问链接                    |
| :active               |   活动链接                      |
| :hover                |   鼠标悬浮                      |
| :focus                |   获得焦点的元素。              |
| :lang(language)       |   lang 属性匹配的元素。         |
| :first-child          |   第一个子元素                  |
| :first-of-type        |   首个匹配元素元素。            |
| :last-of-type         |   最后匹配元素元素。            |
| :only-of-type         |   唯一匹配元素。                |
| :only-child           |   唯一子元素                    |
| :nth-child(n)         |   第n个能匹配的元素             |
| :nth-last-child(n)    |   倒数第n个能匹配的元素         |
| :nth-of-type(n)       |   匹配的第n个元素               |
| :nth-last-of-type(n)  |   匹配的倒数第n个元素           |
| :last-child           |   最后的子元素                  |
| :root                 |   文档的根元素                  |
| :empty                |   空元素                        |
| :target               |   活动元素                      |
| :enabled              |   启用元素                      |
| :disabled             |   禁用元素                      |
| :checked              |   选中元素                      |
| :not(selector)        |   标签反选                      |
| -标签选择器-          |   ---- 优先级 4 ----            |
| *                     |   标签通配                      |
| element               |   标签选择器                    |
| -伪类选择器-          |                                 |
| ::first-letter        |   <p> 元素首字母                |
| ::first-line          |   <p> 元素首行                  |
| ::before              |   <p> 元素内容之前插入          |
| ::after               |   <p> 元素内容之后插入          |
| ::selection           |   用户选中部分                  |
| ---                   |                                 |
| element,element       |   分组选择器                    |
| element element       |   后代选择器                    |
| element>element       |   子元素选择器                  |
| element+element       |   相邻兄弟选择器                |
| element1~element2     |   后续兄弟选择器                |

## JS
### 数据类型
基础类型
- 数值（number）(包装类型)
- 字符串（string）(包装类型)
- 布尔值（boolean）(包装类型)
- undefined
- null

包装属性：包装了相应的属性和方法

复杂类型
- 狭义对象（object）(引用类型)
- 数组（array）(引用类型)
- 函数（function）(函数不会生成新的this上下文，但是局部变量的上下文是独立的)

js中改变基础类型的值会重新生成

### 运算符和优先级
[运算符优先级-MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Operator_Precedence)

|    |                    |                       |
| :- | :----------------  | :-------------------  |
| 20 | ()圆括号           | n/a                   |
| 19 | .                  | 从左                  |
|    | []                 | 从左                  |
|    | new obj()          | n/a                   |
|    | fun()              | 从左                  |
| 18 | new                | 从右                  |
| 17 | _++ / _--          | n/a                   |
| 16 | !                  | 从右                  |
|    | ~                  | 从右                  |
|    | +_ / -_            | 从右                  |
|    | ++_ / --_          | 从右                  |
|    | typeof             | 从右                  |
|    | void               | 从右                  |
|    | delete             | 从右                  |
|    | await              | 从右                  |
| 15 | **                 | 从右                  |
| 14 | * / / / %          | 从左                  |
| 13 | + / -              | 从左                  |
| 12 | << / >> / >>>      | 从左                  |
| 11 | \</<=/>/>=/        | 从左                  |
|    | _ in _             | 从左                  |
|    | _ instanceof _     | 从左                  |
| 12 | ==/!=/===/!===     | 从左                  |
| 9  | &                  | 从左                  |
| 8  | ^                  | 从左                  |
| 7  | |                  | 从左                  |
| 6  | &&                 | 从左                  |
| 5  | ||                 | 从左                  |
| 4  | _ ? _ : _          | 从右                  |
| 3  | =/+=/-=/*=//=/%=<br>\<\<=/>>=/>>>=/&=/^=/\|= | 从右 |
| 2  | yield              | 从右                  |
|    | yield*             | 从右                  |
| 1  | ...                | n/a                   |
| 0  | ,                  | 从左                  |

===值相等 in包含属性 instanceof构造函数  
yield 生成器暂停

- \|/~
- 算术运算
- 位移运算
- 大于等于等
- == / !=
- 逻辑运算 位运算
- 条件运算
- 赋值运算

### 数组内建方法大全
[数组内建方法大全（一）](https://www.jianshu.com/p/cf8b58240886)
[数组内建方法大全（二）](https://www.jianshu.com/p/2e977c89aa3b)

### 闭包
闭包的作用是把函数内的局部变量通过返回函数，从而能够让外部引用  
返回函数时保留了return处的局部变量，但是不包括this  
也就是通过返回出来的函数能够操作原函数内的局部变量，或者用局部变量作this的副本  
如果没有新的变量产生，闭包后也不能产生保存历史变量的效果  
保存历史变量意味着重新执行函数，产生新的局部变量  

*(箭头函数一样能产生闭包)*
```javascript
var ar=[]
for(i=0;i<10;i++){
	ar.push(((x)=>{//箭头函数能够产生局部变量
		return ()=>console.log(x)//箭头函数能够产生闭包
	})(i))
}
ar.forEach((x)=>x())

```

[从这两套题，重新认识JS的this、作用域、闭包、对象](https://juejin.im/post/59aa71d56fb9a0248d24fae3)
1. 函数的this为包装了函数定义的处的上下文环境
2. 箭头函数的this为引用时的上下文环境
3. 返回的函数相当于以返回值摸版在当前环境下定义函数，this为当前的上下文环境
4. 返回箭头函数他居然就带了this了
```javascript
var name = 'window'

var person1 = {
  name: 'person1',
  show1: function () {
    console.log(this.name)
  },
  show2: () => console.log(this.name),
  show3: function () {
    return function () {
      console.log(this.name)
    }
  },
  show4: function () {
    return () => console.log(this.name)
  },
  show5: function () {
    return (function () {
      console.log(this.name)
    })()
  },
  show6: function () {
    return (() => console.log(this.name))()
  }

}
var person2 = { name: 'person2' }

person1.show1()//'person1'
person1.show1.call(person2)//'person2'

person1.show2()//'window'
person1.show2.call(person2)//'window'

person1.show3()()//'window'
person1.show3().call(person2)//'person2'
person1.show3.call(person2)()//'window'

person1.show4()()//'person1'
person1.show4().call(person2)//'person1'
person1.show4.call(person2)()//'person2'

person1.show5()//'window'
person1.show5.call(person2)//'window'

person1.show6()//'person1'
person1.show6.call(person2)//'person2'

```

### iframe
父页面引用iframe的子页面：  
window.frames[0]  
FrameDom.contentWindow  

iframe子页面引用父页面：  
window.parent  
top

父页面引用open的子页面：op=open('url')  
open的子页面引用父页面：window.opener  

获取url：window.location.href


### 运算符和优先级
### 闭包

### 方法
#### new
#### 继承
#### 原型链


### 前端本地存储
[JavaScript 前端存储的几种方式简单介绍](https://www.jianshu.com/p/e7c4b1c72c7b) cookie localStorage sessionStorage indexedDB  
[浅谈 ： web 前端本地存储](https://segmentfault.com/a/1190000011004376) cookie WebStorage(localStorage sessionStorage) webSQL indexedDB localForage  
[很全很全的前端本地存储讲解](https://www.jianshu.com/p/10bbff64ccab) mark  
[前端之路——WebStorage和Cookie](https://www.jianshu.com/p/044c0b3050d1)

**cookie**:服务器通过Set-Cookie让客户端建立Cookie，客户端再次发起请求时会将Cookie反正HTTP响应头中  
4k 每个域名50个 总3000个  
[理解Cookie和Session机制](https://my.oschina.net/xianggao/blog/395675?fromerr)  
[前端必备HTTP技能之cookie技术详解](https://www.jianshu.com/p/2ceeaef92f20)

**WebStorage**：不会被加在请求中，客户端脚本访问不由服务器设置  
一般为5M 浏览器差异

**indexDB**: 250MB 同步/异步 可二进制存储


## 浏览器
### 同源策略和跨域
[同源策略与跨域](https://www.jianshu.com/p/2b9db9d0a63d) (document.domain window.name postMessage 片段识别符 AJAX)  
[浏览器同源政策及其规避方法](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html) (document.domain 片段识别符 window.name window.postMessage+LocalStorage AJAX+WebSocket)  
[跨域的几种方式 ](http://www.cnblogs.com/zhuzhenwei918/p/6759459.htm) (document.domain location.hash window.name postMessage CORS)  


同源策略：
- 端口相同
- 域名相同
- 协议相同

跨域的受限行为：
1. Cookie、LocalStorage 和 IndexDB 无法读取。[前端本地存储](#前端本地存储)
2. Dom无法获取
3. Ajax请求(jsonp只能get)

解决方法：
**1. document.domain**
1. 在同窗口下 不同域名二级域名的iframe
2. 设置document.domain为一级域名
3. 可共享DOM和Cookit

```
window=document.getElementById("myIFrame").contentDocument  
window.parent.document.body
```

服务器也可以在设置Cookie时，指定名为一级域名

**2. window.name**
1. 同窗口页面
2. 通过window.name共享数据
3. 2M

[JS跨域--window.name](https://www.jianshu.com/p/43ff69d076e3)
```javascript
    var boo = false;
    var iframe = document.createElement('iframe');
    var loadData = function() {
        if (boo) {
            var data = iframe.contentWindow.name;    //获取window.name
            console.log(data); 
            //销毁数据   
            iframe.contentWindow.document.write('');
            iframe.contentWindow.close();
            document.body.removeChild(iframe);
        } else {
            boo = true;
            iframe.contentWindow.location = "b.html";    // 设置的代理文件,iframe重新载入
        }  
    };
    iframe.src = 'https://xxx.github.io/xxx';
    if (iframe.attachEvent) {
        iframe.attachEvent('onload', loadData);
    } else {
        iframe.onload  = loadData;
    }
    document.body.appendChild(iframe);
```

**3. window.postMessage**
1. H5 跨源通讯方法 window.postMessage  
2. 跨源 跨窗口

[html5 postMessage解决跨域、跨窗口消息传递](https://www.cnblogs.com/dolphinX/p/3464056.html)

window.postMessage(data,origin)
- origin: 同域使用相对路径'/xxx' 跨域使用'协议+主机+端口号' '*'通配域

window.addEventListener('message', function(e) {  
  console.log(e.data);  
},false)
- event: 绑定事件，不能以on前缀
- function: 回调
- useCapture：Capture/Bubbing

- e.data：message
- e.source：发送消息的窗口对象
- e.origin：发送消息窗口的源（协议+主机+端口号）

```html
<button onClick='openpage()' id='openpage'>openpage</button><br>
<button onClick='postm()'>postMessage</button>
<script>
    window.addEventListener('message',function(e){'event:',console.log(e,e.data)})
    var opg
    function openpage(){
        opg=open('./test.html')
    }
    function postm(){
        if(opener){
            console.log( 'opener',opener.postMessage('hello','/'))
        }
        if(opg){
            console.log('opg', opg.postMessage('hello','/'))
        }
    }
</script>
```

**4. 片段标识符**  
1. 同窗口下
2. 修改URL#后的片段识别符
```javascript
//父窗口
var src = originURL + '#' + data;
document.getElementById('myIFrame').src = src
//或者子窗口  
parent.location.href= target + "#" + hash
//上面的window可以是页面中iframe的contentWindow属性
//window.open的返回值
//通过name或下标从window.frames取到的值


//接收
window.onhashchange = checkMessage;
function checkMessage() {
  var message = window.location.hash;
  // ...
}
```

**-- 跨源服务器请求 --**  
Flash 服务器代理 JSONP CORS  

*（直接用XMLHttpRequest()无法跨域）*

**5. AJAX-JSONP**  
1. 通过script标签引入外源脚本
2. 用GET请求
(为了保持刷新增加请求参数？？)

**6. AJAX-CORS**  
[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)  
（Cross-origin resource sharing）  

**简单请求**
1. 方法为： HEAD GET  POST
2. 头信息在以下范围内：  
 i. Accept  
 ii. Accept-Language  
 iii. Content-Language  
 iv. Last-Event-ID  
 v. Content-Type 为1. application/x-www-form-urlencoded、2. multipart/form-data、3. text/plain


使用XMLHttpRequest向服务器发请求(浏览器加Origin字段)
服务器匹配Origin许可范围  
 返回Access-Control-Allow-Origin字段表示通过  
 XMLHttpRequest onerror失败(状态可能为200)

**非简单请求**  
浏览器会先发送一次'预检'请求，然后再发送XMLHttpRequest

**7. AJAX-WebSocket**  

### 事件循环

### 浏览器缓存机制




