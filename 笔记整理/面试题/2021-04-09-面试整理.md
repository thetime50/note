# 2021-04-09-面试整理

### HTML5 语义化
https://www.jianshu.com/p/b226910034f2

![语义化](./img/2021-04-09-语义化.webp)


### 原型继承
[原型继承](../../日志/2018-2019/log-2019-02-15.md)
```js
// PrimaryStudent构造函数:
function PrimaryStudent(props) {
    Student.call(this, props);
    this.grade = props.grade || 1;
}

// 空函数F:
function F() {
}

F.prototype = Student.prototype;
PrimaryStudent.prototype = new F();
PrimaryStudent.prototype.constructor = PrimaryStudent;

// 继续在PrimaryStudent原型（就是new F()对象）上定义方法：
PrimaryStudent.prototype.getGrade = function () {
    return this.grade;
};

// 创建xiaoming:
var xiaoming = new PrimaryStudent({
    name: '小明',
    grade: 2
});
xiaoming.name; // '小明'
xiaoming.grade; // 2


/*
## 子类构造函数中调用父类构造函数 Parent.call(this,...args)
## 子类的原创相当于父类的一个(空)实例，不执行实际的初始化函数，只有原先没有实例属性
空类(空函数)
同个原型 prototype
Child.prototype = new
Child.prototype.constructor = Parent
*/
```

## 01 pft
### 1. 用flex布局实现手机app header body footer 上中下3栏布局
```html
<body>
    <header>
    </header>
    <section>
    </section>
    <footer>
    </footer>
</body>

```
```css
/*
display:flex-layout;
flex-direction：column/row;
flex-wrap:nowrap;
justify-content:center; // 轴向分布
align-items:stretch; // 正交对齐
align-content:stretch; // 整体对齐
*/
body{
    display:flex;
    flex-wrap:nowrap;
    flex-direction:column;
    justify-content:center;
    align-items:stretch;
    align-content:stretch;
    >*{
        min-width:0;
        min-height:0;
    }
}

header{
    flex:0 0 auto;
}
section{
    flex:1 1 auto;
}
footer{
    flex:0 0 auto;
}
```

### 2. 按下面测试用例实现createFlow  
```js
const delay=(ms)=>new Promise((resolve)=>setTimeout(resulve,ms));  
const subFlow = createFlow([()=>delay(1000).then(()=>log("c"))]);  
createFlow([
    ()=>log('a'),()=>log('b'),
    sufFlow,
    [()=>delay(1000).then(()=>log('d')),()=>('e')]
]).run(()=>{
    console.log("done")
})

//********************
let log = console.log
function createFlow(list){
    let result ={
        list,
    }
    async function runList (list){
        for(let index in list){
            let val = list[index]
            if(Array.isArray(val)){
                await runList(val)
            }else{
                await val()
            }
        }
    }
    result.run = async (cb)=>{
        await runList(this.list)
        cb()
    }
    return result
}

```

### 3. 实现new方法
```js
function myNew(){
    let constructor = [].shift.call(arguments)
    let obj = {}
    obj.__proto__ = constructor.prototype
    let r = constructor.call(obj,arguments)
    return typeof(r)=='objet' ? r : obj
}
```

### 4. 简单实现js面向对象继承
```js
function Parent(...args){}

function Child(...args){
    Parent.call(this,...args)
    this.xxx = 'xxx'
}

function F(){}
F.prototype = Parent.prototype
Child.prototype = new F
Child.prototype.construetore = Parent

Child.prototype.fn = function (){}

new Child('xxxx')


```

### 5. 简单实现EventEmitter(订阅发布模式)
```js
class EventBus{
    constructor(){
        this.group={}
    }
    emit(event,...args){
        if(this.group[event]){
            this.group[event].forEach((v,i,a)=>{
                v(...args)
            })
        }
    }
    emit(event,fn){
        if(!this.group[event]){
            this.group[event] = []
        }
        this.group[event].push(fn)
    }
}
```

### 6. 实现bind方法
```js
Function.prototype.bind = function(context){
    let that = this
    let bindArgs = [].slice.call(arguments,1)

    function Fn(){}
    function fBound(){
        let args = [].slice.call(arguments)
        return that.call(
            this instanceof fBound ? this : that ,
            bindArgs.concat(args)
        )
    }
    Fn.protorype = this.prototype
    fBound.prototype = new Fn
    return fBound
}

/**
1. that bindArgs
2. Fn fBound
3. Fn.prototype fBound.prototype 
*/

```

### 7. 实现防抖
```js
function getDebounce(fn,ms){
    let th 
    return function(...args){
        if(!th){
            let that = this
            th = setTimeout(()=>{
                fn.call(that,...args)
                th = null
            },ms)
        }
    }
}
```

### 8. 以下代码输出什么
```js
for(var i=0;i<5;i++){
    console.log(i)
}

for(var s=0;i<s;s++){
    setTimeout(()=>{
        console.log(s)
    },100)
}
/*
0
1
2
3
4

5
5
5
5
5

*/
```


### 9. 以下代码输出什么
```js
setTimeout(function(){
    console.log(4)
},0)
new Promise(function(resolve){
    console.log(1)
    for(var i=0; i<1000; i++){
        i=9999 && resolve()
    }
    console.log(2)
}).then(function(){
    console.log(5)
})
console.log(3)

/*
12354
*/
```

### 10. js里0.1+0.2=? 为什么
0.29999 数据精度问题
双精度浮点数采用 64 位存储 (8 个字节)  
1位符号位  
11指数部分，即指数部分能表示的最大值是 2047（2^11-1）

https://www.zhoulujun.cn/html/theory/ComputerScienceTechnology/Constitution/2016_0714_7860.html

这两个边界值可以分别通过访问 Number 对象的 MAX_VALUE 属性和 MIN_VALUE 属性来获取：
```js
Number.MAX_VALUE; // 1.7976931348623157e+308
Number.MIN_VALUE; // 5e-324
```
如果数字超过最大值或最小值，JavaScript 将返回一个不正确的值，这称为 “正向溢出(overflow)” 或 “负向溢出(underflow)” 。 
```js
Number.MAX_VALUE+1 == Number.MAX_VALUE; //true
Number.MAX_VALUE+1e292; //Infinity
Number.MIN_VALUE + 1; //1
Number.MIN_VALUE - 3e-324; //0
Number.MIN_VALUE - 2e-324; //5e-324
```
