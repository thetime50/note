
# 深入组件
## 组件注册

使用 app.component('my-component-name', {config}) 注册

如果组件是用kebab-case (短横线分隔命名) 定义，使用时必须是 kebab-case
组件是用PascalCase (首字母大写命名) 定义， 使用时可以是kebab-case 和 PascalCase


```js
/* 全局注册 */
const app = Vue.createApp({})
// 这个是用vue实例component方法 全局注册组件
app.component('component-a', {
  /* ... */
})

/* 局部注册 */
// 这个是在根组件上注册子组件 传递根组件的配置选项 
// 只有在 app 根组件上有效
const app = Vue.createApp({
  components: {
    'component-a': ComponentA,
    'component-b': ComponentB
  }
})

/* 或者其他组件的components 选项 */
import ComponentA from './ComponentA.vue'

export default {
  components: {
    ComponentA
  }
  // ...
}
```

## props

### props 定义
```js
export default{
/* 1. 数组 */
props: ['title', 'likes', 'isPublished', 'commentIds', 'author']

/* 2. 对象-类型 */
props: {
  title: String,
  likes: Number,
  isPublished: Boolean,
  commentIds: Array,
  author: Object,
  callback: Function,
  contactsPromise: Promise // 或任何其他构造函数
}
}
```

### 引用
```html
<blog-post v-bind:id="post.id" v-bind:title="post.title"></blog-post>
<blog-post v-bind="{
  id: 1,
  title: 'My Journey with Vue'
}"></blog-post>

```

### 导向数据流
不应该在一个子组件内部改变 prop。Vue 会在浏览器的控制台中发出警告。

场景
```js
/* 1. 在data中用this.myProp 初始化数据 */
{
    props: ['initialCounter'],
    data() {
        return {
            counter: this.initialCounter
        }
    }
}

/* 2. computed 里面引用prop 进行加工计算 */
{
    props: ['size'],
    computed: {
        normalizedSize: function () {
            return this.size.trim().toLowerCase()
        }
    }
}
```

### Prop 验证

1. {type,default,required}
2. { validator:function(){ return true } } // 返回true表示数据有效

```js
app.component('my-component', {
  props: {
    // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)
    propA: Number,
    // 多个可能的类型
    propB: [String, Number],
    // 必填的字符串
    propC: {
      type: String,
      required: true
    },
    // 带有默认值的数字
    propD: {
      type: Number,
      default: 100
    },
    // 带有默认值的对象
    propE: {
      type: Object,
      // 对象或数组默认值必须从一个工厂函数获取
      default: function() {
        return { message: 'hello' }
      }
    },
    // 自定义验证函数
    propF: {
      validator: function(value) {
        // 这个值必须匹配下列字符串中的一个
        return ['success', 'warning', 'danger'].indexOf(value) !== -1
      }
    },
    // 具有默认值的函数
    propG: {
      type: Function,
      // 与对象或数组默认值不同，这不是一个工厂函数 —— 这是一个用作默认值的函数
      default: function() {
        return 'Default function'
      }
    }
  }
})


```
### Prop 的大小写命名 (camelCase vs kebab-case)

使用 DOM 中的模板时，camelCase (驼峰命名法) 的 prop 名需要使用其等价的 kebab-case (短横线分隔命名) 命名  
如果你使用字符串模板，那么这个限制就不存在。




## 非 Prop 的 Attribute
### Attribute 继承

**单个根节点组件**，非 prop attribute 将自动添加到根节点的 attribute 中  
@change事件绑定也一样，会自动绑定在根组件上并出现在 $attrs 中 onXxxx

this.$attrs 是个 proxy  
demo https://github.com/thetime50/vue3-practice/blob/main/src/views/vue3Test/thoroughComponent/noPropAttribute.vue

### 禁用 Attribute 继承

[proxy mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy)
[（JS基础）Proxy 对象 与 Reflect 对象](https://blog.csdn.net/weixin_33806914/article/details/91454170)

在组件的选项中设置 inheritAttrs: false禁用根节点属性继承
设置了禁止继承后 class和style 都不会自动挂载到根元素并且添加到 $attr 中


### 多个根节点上的 Attribute 继承

多个根节点不会自动绑定未定义属性，并且会发出运行时警告


## 自定义事件

**事件名不会自动化大小写转换** (vue2也是一样的)

- 组件emit选项
- 组件定义了原生同名的事件原生事件会被组件事件替代 (vue2中监听不到原生事件 要加.native修饰符)
```js
{
  emit:['in-focus', 'submit'],
}
```

### 验证抛出的事件

用对象语法严重抛出事件参数
```js
app.component('custom-form', {
  emits: {
    // 没有验证
    click: null,

    // 验证submit 事件
    submit: ({ email, password }) => {
      if (email && password) {
        return true
      } else {
        console.warn('Invalid submit event payload!')
        return false
      }
    }
  },
  methods: {
    submitForm() {
      this.$emit('submit', { email, password })
    }
  }
})
```

### v-model参数
默认情况下，组件上的 v-model 使用 modelValue 作为 prop 和 update:modelValue 作为事件  
或者 v-model:xx 指定同步的属性
```html
<script>
const app = Vue.createApp({})

app.component('my-component', {
  props: {
    foo: String
  },
  template: `
    <input 
      type="text"
      :value="foo"
      @input="$emit('update:foo', $event.target.value)">
  `
})
</script>
<my-component v-model:foo="bar"></my-component>
```

### 处理 v-model 修饰符支持

v-model 会绑定数据据prop modelValue 修饰符prop modelModifiers
v-model:arg 会绑定数据据prop arg 修饰符prop argModifiers

