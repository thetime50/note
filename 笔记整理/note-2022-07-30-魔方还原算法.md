
# 魔方还原算法


1. [魔方还原算法(一) 概述](https://zhuanlan.zhihu.com/p/377413763)
2. [魔方还原算法二——科先巴的二阶段算法](https://zhuanlan.zhihu.com/p/386717204)
3. [魔方还原算法(三) 上帝算法](https://zhuanlan.zhihu.com/p/393195676)

[魔方还原-科先巴两阶段算法解读](https://zhuanlan.zhihu.com/p/519944741)  
[The Two-Phase-Algorithm](http://kociemba.org/cube.htm)


## 1 概述
[魔方还原算法(一) 概述](https://zhuanlan.zhihu.com/p/377413763)

### 辛马斯特标记(Singmaster Notation )

L R U D F B  
L' R' U' D' F' B'  
L2 R2 U2 D2 F2 B2  
中层 MU MF ML MU' MF' ML'  
整体 CU CF CL CU' CF' CL'  

记步方式
- HTM：Half Turn Metric，任意层的任意转动记为一步
- QTM：Quarter Turn Metric，90°的转动才记作一步，180°的转动记为两步
还有其他的记步方式不说明了，最主要的就是这两种记步方式，<u>本系列文章所用的记步方式为 HTM，本文用不到</u>，下篇文章会用到，本文只是做介绍。

### COFP 解法
1. Cross ：底层十字，无公式，按经验来，高手一般都是 7 步以内
2. F2L：First two Layer：同时复原前两层，41 个公式
3. OLL：Orient Last Layer：复原顶层，只是顶面的颜色复原了，位置没有复原，57个公式
4. PLL：Permutation of Last Layer：调整棱块角块位置，完全复原顶层，21 个公式

### 上帝数

- **上帝数** 上帝之数指的是还原一个任意打乱的魔方需要的最少步数，在 2010 年，几位数学家通力合作在谷歌帮助下证明三阶魔方的上帝之数为 20。20 为采用HTM记步方式得到的步数，若采用 QTM 为 26。[卢昌海 - 魔方与 "上帝之数"](https://changhai.org/articles/science/mathematics/rubikcube.php)

- **恶魔算法** 有一个转动序列，如果重复操作能够遍历魔方的所有状态，那么对于任意一个魔方状态，我们都可以应用这个转动序列使魔方达到还原状态，这就是恶魔算法。

### 魔方状态数
    - 8 个角块，3个方向: 8! * 3^8
    - 12 个棱块，2个方向: 12! * 2^12
    - *限制*
    - 

1. 魔方是一个置换群
2. 两个元素交换叫对换， 偶数次交换叫偶置换，奇数次交换叫奇置换
3. 所有置换可以分为个数相等的奇置换和偶置换，任意一个置换可以分解成多个对换之积
    - [任意一个置换群，要么全是偶置换，要么奇偶各一半。且对于一个对称群，奇偶各一半](https://www.zhihu.com/question/459332254)  
      置换群里任意一个偶置换都有一个置换a*奇置换得到
4. 偶偶 = 偶，奇奇 = 偶， 奇偶 = 奇， 偶奇 = 奇

### 三约束
#### 位置
在一次顺时针旋转中，棱块发生3次对换-奇置换，角块也发生3次对换-奇置换，  
奇置换无法通过合法转动得到，置换群里奇置换和偶置换数量相等，所以合法状态要再乘以1/2

#### 方向
科先巴的二阶段算法中的定义方法： 

- 棱块用0,1 来表示未翻转和翻转，只有F和B层的转动会改变棱块方向，UDLR层的转动不改变棱块方向 // 改变棱块的方向需要3个面参与，所以只有两个面参与的旋转不会改变棱块的反向

- 角块用0,1,2表示旋转方向，0未旋转 1顺时针旋转 2逆时针旋转，当前位置对比以U层和D层作为参考面。例如左前下块的复原块做一个R被转到左前上，那么这方块对应顶面是顺时针旋转的


最后 
- 棱块若 F B层翻转，翻转数总是偶数个 所有的棱块方向值的和为 2 的倍数 (4的倍数？)

- 角块 若 L，R，F，B 某一层转动，有两个角块顺时针转动，另外两个角块逆时针转动，所以方向值的总和变为 同样为 3 的倍数

最终状态总数为：
（8! * 3^8 * 12! * 2^12） / （3*4）


## 2 科先巴的二阶段算法


